-- 描述：克隆表或克隆列

-- 随着数据量的增长，数据库的查询性能也会随之下降。即使查询结果可能只有很少的几千行，遍历表中积累的数据也可能使得整个查询的性能变得极差。即使使用了索引，但随着数据的增长，索引的作用变得非常有限。本章的目标就是要优化数据库的结构来提升查询的性能以及支持表的平滑扩展。这里的反模式是利用人工手动划分不同的表存储不同时间段（或其他条件）的结构相同的数据。

--按时间创建表
CREATE TABLE Bugs_2008 ( . . . );
CREATE TABLE Bugs_2009 ( . . . );
CREATE TABLE Bugs_2010 ( . . . );

-- 问题1：不断产生新表
-- 由于要将数据添加进数据库，于是根据要添加的数据的值选择合适的表就成了你的责任：
INSERT INTO Bugs_2010 (..., date_reported, ...) VALUES (... , '2010-06-01' , ...);
-- 让我们快进到2011年1月1日。你的程序在添加新的bug报告时不断的报错，因为你忘记添加一张叫做 Bugs_2011 的新表。

-- 问题2：管理数据的完整性
-- 我们要严格限定bug的时间归属于哪张表，需要创建一些约束。
CREATE TABLE Bugs_2009 (
-- other columns
	date_reported DATE CHECK (EXTRACT(YEAR FROM date_reported) = 2009)
);
CREATE TABLE Bugs_2010 (
-- other columns
	date_reported DATE CHECK (EXTRACT(YEAR FROM date_reported) = 2010)
);

-- 问题3：数据同步
-- 当你跟新一个bug时间的时候，也有可能改变它所归属的表。
-- 更新
UPDATE Bugs_2010
SET date_reported = '2009-12-27'
WHERE bug_id = 1234;
-- 新增到2009
INSERT INTO Bugs_2009 (bug_id, date_reported, ...)
SELECT bug_id, date_reported, ...
FROM Bugs_2010
WHERE bug_id = 1234;
-- 删除2010
DELETE FROM Bugs_2010 WHERE bug_id = 1234;

-- 问题4：确保一致性
-- 需要确保所有被分割出来的表中的主键都是唯一的。如果你需要从一张表中移动一条记录到另一张表中，需要保证被移动记录的主键值不会和目标表中的主键记录冲突。如果使用一个支持序列化对象的数据库，那么可以使用一个简单的序列来确保主键值在所有的分割表中都是唯一的。对于那些只支持单表 ID 唯一的数据库产品来说，实现这样的功能变得很不优雅。你不得不定义一张额外的表来存储产品主键的值。
CREATE TABLE BugsIdGenerator (bug_id SERIAL PRIMARY KEY);

INSERT INTO BugsIdGenerator (bug_id)
VALUES (DEFAULT);

INSERT INTO Bugs_2010 (bug_id, . . .)
VALUES (LAST_INSERT_ID(), . . .);

-- 问题5：跨表查询
-- 不可避免地，你的老板肯定会需要查询多张表中的数据。比如，他可能会要求查询所有的Bug总数，不管是哪一年报告的。你可以使用 UNION 将所有分割表联合起来得到一个重构过的Bug 集合并将其作为一个衍生表进行查询：
SELECT b.status, COUNT(*) AS count_per_status
  FROM (SELECT *
          FROM Bugs_2008
        UNION
        SELECT *
          FROM Bugs_2009
        UNION
        SELECT *
          FROM Bugs_2010) AS b
 GROUP BY b.status;
-- 年复一年，你创建了越来越多的表，比如Bugs_2011，你需要不断地更新程序代码来引入这些新创建的表。

-- 问题6：同步元数据
-- 你的老板要你在表中加入新的一列，如果你只加在新生成和在使用的表中，而不去管历史表，那么在以后的连表查询中使用前一段描述的那个UNION查询所有的分割表，就会碰到一个新问题：当多张表具有相同的列时才能使用UNION。如果多张表的列不完全相同，你就必须指明所有表都同时拥有的列，而不可以再使用“*”通配符。

-- 问题7：管理引用完整性
-- 如果一个关联表，比如Comments引用了 Bugs，这个关联表就不能声明一个外键了。一个外键必须指定单个表，但在这个案例中父表被拆分成很多个表。

-- 问题8：标识元数据分裂列
-- 列也可能根据元数据分裂。你可以创建一个含有很多列的表，这些列按照它们的类别扩展，就像我们在本章最开始看到的那个故事一样。我们的Bug数据库中可能碰到的另一个事例是：有一张表记录了项目指标的概要信息，其中的每一列存储了一个小计。具体来说，在如下这张表中，增加一个 bugs_fixed_2011 列只是时间问题。

-- 合理使用：
-- 手动分割表的一种合理的使用方式是归档数据——将历史数据从归档数据中移除。通常在过期数据查询变得非常稀少时才这样做。将数据归档到和当前表结构相兼容的新表中，既能支持偶尔做数据分析时的查询，同时也能让日常数据查询变得非常高效。

-- 解决1：使用水平分区
-- 你可以使用一种称为水平分区 或者分片 的数据库特性来分割大数据量的表，同时又不用担心那些分割表所带来的缺陷。你仅需要定义一些规则来拆分一张逻辑表，数据库会为你管理余下的所有事情。物理上来说，表的确是被拆分了，但你依旧可以像查询单一表那样执行SQL查询语句。定义每个表拆分的方式是非常灵活的。比如，使用MySQL5.1所支持的分区特性，你可以在CREATE TABLE语句中将分区规则作为可选参数。
CREATE TABLE Bugs (
	bug_id SERIAL PRIMARY KEY,
	-- other columns
	date_reported DATE
) PARTITION BY HASH ( YEAR(date_reported) )
PARTITIONS 4;
-- 上例中分割数据库的方式和这章最开始讲到的方法类似，根据date_reported列里的年份对数据进行拆分。然而，这么做的优势在于，相比于手动拆分表，你永远不用担心数据会放入错误的分割表中，即使date_reported列的值更新了。而且，你不必引用所有的分割表就能对bugs表进行整体的查询操作。

-- 解决2：使用垂直分区
-- 鉴于水平分区是根据行来对表进行拆分的，垂直分区就是根据列来对表进行拆分。当某些列非常庞大或者很少使用的时候，对表进行按列拆分会比较有优势。BLOB 类型和 TEXT 类型的列的大小是可变的，可能非常大。为了提高存储和查询的性能，有些数据库自动地将这些类型的列和表中其他的列分开进行存储。如果你进行一个不包含 BLOB 或者TEXT类型的查询，就可以更高效地获取其他的列。但如果使用一个通配符“*”来进行查询，库会返回这张表中所包含的所有列，包括那些类型为 BLOB 或者 TEXT 的列。

-- 忠告：别叫数据繁衍元数据。